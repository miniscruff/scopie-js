{
  "version": 3,
  "sources": ["../src/scopie.js"],
  "sourcesContent": ["/**\n * Authorization engine for configuring per user per feature access control.\n * Access is configured via plain text and handled directly via code.\n * Configuration storage is controlled by you, scopie just handles the logic.\n *\n * See {@link https://scopie.dev Scopie Docs} for full specification.\n */\n\n\n/** arraySeparator is the character between array elements.\n * See {@link https://scopie.dev/specification/terms/#block block term} for how blocks are formatted.\n */\nexport const arraySeparator = '|';\n\n/** blockSeparator is the character between blocks.\n * See {@link https://scopie.dev/specification/terms/#block block term} for how blocks are formatted.\n */\nexport const blockSeparator = '/';\n\n/** wildcard is the character that matches any value in a block.\n * See {@link https://scopie.dev/specification/terms/#block block term} for how blocks are formatted.\n */\nexport const wildcard = '*';\n\n/** varPrefix is the character that prefixes variables in blocks.\n * See {@link https://scopie.dev/specification/terms/#block block term} for how blocks are formatted.\n */\nexport const varPrefix = '@';\n\n/** allowGrant is the value used to denote an allowed permission.\n * See {@link https://scopie.dev/specification/terms/#grant permission term} for how actions are checked.\n */\nexport const allowGrant = \"allow\";\n\n/** denyGrant is the value used to denote a denied permission.\n * See {@link https://scopie.dev/specification/terms/#grant permission term} for how actions are checked.\n */\nexport const denyGrant = \"deny\";\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a literal block.\n * @access private\n */\nfunction isValidLiteral(char) {\n  if (char >= 'a' && char <= 'z') {\n    return true;\n  }\n\n  if (char >= 'A' && char <= 'Z') {\n    return true;\n  }\n\n  if (char >= '0' && char <= '9') {\n    return true;\n  }\n\n  return char === '_' || char === '-';\n}\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a block.\n * @access private\n */\nfunction isValidCharacter(char) {\n  return isValidLiteral(char) || char === varPrefix || char === wildcard;\n}\n\n/** Calculates the end of an array element\n * @param {string} value - Value of our action we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the array element\n * @access private\n */\nfunction endOfArrayElement(value, start) {\n  for (let i = start + 1; i < value.length; i += 1) {\n    if (value[i] === blockSeparator || value[i] === arraySeparator) {\n      return i;\n    }\n  }\n\n  return value.length;\n}\n\nfunction skipGrant(value) {\n\tif (value.startsWith(denyGrant)) {\n\t\treturn 5\n\t}\n\n\tif (value.startsWith(allowGrant)) {\n\t\treturn 6\n\t}\n\n\tthrow new Error(\"scopie-107: permission does not start with a grant\")\n}\n\n/** Calculates the end of a action block\n * @param {string} category - Value to use when returning an error for our category\n * @param {string} value - Value of our action we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the action block\n * @access private\n */\nfunction endOfBlock(category, value, start) {\n  for (let i = start; i < value.length; i += 1) {\n    if (value[i] === blockSeparator) {\n      return i;\n    } if (value[i] === arraySeparator) {\n      continue;\n    } else if (!isValidCharacter(value[i])) {\n      throw new Error(`scopie-100 in ${category}: invalid character '${value[i]}'`);\n    }\n  }\n\n  return value.length;\n}\n\n/** Compares two strings with respect to variables and wildcards.\n * @param {string} permission\n * @param {int} permissionLeft\n * @param {int} permissionSlider\n * @param {string} action\n * @param {int} actionLeft\n * @param {int} actionSlider\n * @param {Map<string,string>} vars\n * @returns {boolean} Whether or not our permission block matches the action block\n * @access private\n */\nfunction compareBlock(permission, permissionLeft, permissionSlider, action, actionLeft, actionSlider, vars) {\n  if (permission[permissionLeft] === varPrefix) {\n    const key = permission.substring(permissionLeft + 1, permissionSlider);\n    if (!vars.has(key)) {\n      throw new Error(`scopie-104: variable '${key}' not found`);\n    }\n\n    const varValue = vars.get(key);\n    return varValue === action.substring(actionLeft, actionSlider);\n  }\n\n  if (permissionSlider - permissionLeft === 1 && permission[permissionLeft] === wildcard) {\n    return true;\n  }\n\n  if (permission.substring(permissionLeft, permissionSlider).indexOf(arraySeparator) >= 0) {\n    for (; permissionLeft < permissionSlider;) {\n      const arrayRight = endOfArrayElement(permission, permissionLeft);\n\n      if (permission[permissionLeft] === varPrefix) {\n        throw new Error(`scopie-101: variable '${permission.substring(permissionLeft + 1, arrayRight)}' found in array block`);\n      }\n\n      if (permission[permissionLeft] === wildcard) {\n        if (arrayRight - permissionLeft > 1 && permission[permissionLeft + 1] === wildcard) {\n          throw new Error('scopie-103: super wildcard found in array block');\n        }\n\n        throw new Error('scopie-102: wildcard found in array block');\n      }\n\n      if (permission.substring(permissionLeft, arrayRight) === action.substring(actionLeft, actionSlider)) {\n        return true;\n      }\n\n      permissionLeft = arrayRight + 1;\n    }\n\n    return false;\n  }\n\n  return permission.substring(permissionLeft, permissionSlider) === action.substring(actionLeft, actionSlider);\n}\n\n/** Determines if an permission matches a action\n * @param {string} action\n * @param {string} permission\n * @param {Map<string,string>} vars - Variables for translations\n * @returns {boolean} Whether or not the action matches the permission\n * @access private\n */\nfunction compareActionToPermission(action, permission, vars) {\n  // Skip the grant prefix for permissions\n  let permissionLeft = skipGrant(permission);\n  let actionLeft = 0;\n  let permissionSlider = 0;\n  let actionSlider = 0;\n\n  for (; permissionLeft < permission.length || actionLeft < action.length;) {\n    // In case one is longer then the other\n    if ((permissionLeft < permission.length) !== (actionLeft < action.length)) {\n      return false;\n    }\n\n    actionSlider = endOfBlock('action', action, actionLeft);\n    permissionSlider = endOfBlock('permission', permission, permissionLeft);\n\n    // Super wildcards are checked here as it skips the who rest of the checks.\n    if (\n      permissionSlider - permissionLeft === 2\n      && permission[permissionLeft] === wildcard\n      && permission[permissionLeft + 1] === wildcard\n    ) {\n      if (permission.length > permissionSlider) {\n        throw new Error('scopie-105: super wildcard not in the last block');\n      }\n\n      return true;\n    }\n    if (!compareBlock(\n      permission,\n      permissionLeft,\n      permissionSlider,\n      action,\n      actionLeft,\n      actionSlider,\n      vars,\n    )) {\n      return false;\n    }\n\n    actionLeft = actionSlider + 1;\n    permissionLeft = permissionSlider + 1;\n  }\n\n  return true;\n}\n\n/**\n * Is Allowed determines whether or not the actions are allowed with the given permissions.\n * @param {string[]} actions - actions specifies one or more actions our user must match. When using more then one action, they are treated as a series of OR conditions, and an user will be allowed if they match any of the actions.\n * @param {string[]} permissions - permissions specifies one or more permissions our requesting actions has to have to be allowed access.\n * @param {object} vars - An optional dictionary or map of variable to values. Variable keys should not start with `@`\n * @returns boolean - Whether or not the actions are allowed with the given permissions.\n * @throws Any invalid action or permission issues, see {@link https://scopie.dev/specification/errors/ scopie errors} for possible issues.\n * @example\n * // returns true\n * isAllowed(\n *   [\"accounts/thor/edit\"],         // actions\n *   [\"allow:accounts/@username/*\"], // permissions\n *   { \"username\": \"thor\" },         // vars\n * )\n */\nexport function isAllowed(actions, permissions, vars) {\n  if (permissions.length === 0) {\n    return false;\n  }\n\n  if (actions.length === 0) {\n    throw new Error('scopie-106 in action: actions was empty');\n  }\n\n  let varMap;\n  if (vars) {\n    varMap = new Map(Object.entries(vars));\n  }\n\n  let hasBeenAllowed = false;\n\n  for (let permissionIndex = 0; permissionIndex < permissions.length; permissionIndex += 1) {\n    const permission = permissions[permissionIndex];\n    if (permission.length === 0) {\n      throw new Error('scopie-106 in permission: permission was empty');\n    }\n\n    const isAllowBlock = permission[0] === 'a';\n    if (isAllowBlock && hasBeenAllowed) {\n      continue;\n    }\n\n    for (let actionIndex = 0; actionIndex < actions.length; actionIndex += 1) {\n      const action = actions[actionIndex];\n      if (action.length === 0) {\n        throw new Error('scopie-106 in action: action was empty');\n      }\n\n      const match = compareActionToPermission(action, permission, varMap);\n      if (match && isAllowBlock) {\n        hasBeenAllowed = true;\n      } else if (match && !isAllowBlock) {\n        return false;\n      }\n    }\n  }\n\n  return hasBeenAllowed;\n}\n\n/**\n * Determines whether or not the actions are valid according to scopie specifications.\n * @param {string[]} actions - action or permissions to check\n * @returns {Error|undefined} If the action are invalid, the validation error is returned,\n * otherwise undefined is returned.\n * @example\n * // returns undefined\n * validateActions([\"accounts/thor/edit\"])\n */\nexport function validateActions(actions) {\n  if (actions.length === 0) {\n    return new Error('scopie-106: action array was empty');\n  }\n\n  for (let action of actions) {\n    if (action.length === 0) {\n      return new Error('scopie-106: action was empty');\n    }\n\n    for (let i = 0; i < action.length; i += 1) {\n      if (!isValidLiteral(action[i]) && action[i] !== blockSeparator) {\n        return new Error(`scopie-100: invalid character '${action[i]}'`);\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Determines whether or not the permissions are valid according to scopie specifications.\n * @param {string[]} permissions - permissions to check\n * @returns {Error|undefined} If the permissions are invalid, the validation error is returned,\n * otherwise undefined is returned.\n * @example\n * // returns undefined\n * validatePermissions([\"grant:accounts/thor/*\"])\n */\nexport function validatePermissions(permissions) {\n  if (permissions.length === 0) {\n    return new Error('scopie-106: permission array was empty');\n  }\n\n  for (let permission of permissions) {\n    if (permission.length === 0) {\n      return new Error('scopie-106: permission was empty');\n    }\n\n    let inArray = false;\n    let i = 0;\n\n    try {\n      i = skipGrant(permission)\n    } catch(e) {\n      return e\n    }\n\n    for (; i < permission.length; i += 1) {\n      if (permission[i] === blockSeparator) {\n        inArray = false;\n        continue;\n      }\n\n      if (permission[i] === arraySeparator) {\n        inArray = true;\n        continue;\n      }\n\n      if (inArray) {\n        if (permission[i] === wildcard && i < permission.length - 1 && permission[i + 1] === wildcard) {\n          return new Error('scopie-103: super wildcard found in array block');\n        }\n\n        if (permission[i] === wildcard) {\n          return new Error('scopie-102: wildcard found in array block');\n        }\n\n        if (permission[i] === varPrefix) {\n          const end = endOfArrayElement(permission, i);\n          return new Error(`scopie-101: variable '${permission.substring(i + 1, end)}' found in array block`);\n        }\n      }\n\n      if (!isValidCharacter(permission[i])) {\n        return new Error(`scopie-100: invalid character '${permission[i]}'`);\n      }\n\n      if (permission[i] === wildcard && i < permission.length - 1 && permission[i + 1] === wildcard\n        && i < permission.length - 2) {\n        return new Error('scopie-105: super wildcard not in the last block');\n      }\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": []
}
