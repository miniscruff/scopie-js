{
  "version": 3,
  "sources": ["../src/scopie.js"],
  "sourcesContent": ["export const arraySeperator = '|';\nexport const blockSeperator = '/';\nexport const wildcard = '*';\nexport const varPrefix = '@';\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a scope.\n */\nfunction isValidCharacter(char) {\n  if (char >= 'a' && char <= 'z') {\n    return true;\n  }\n\n  if (char >= 'A' && char <= 'Z') {\n    return true;\n  }\n\n  if (char >= '0' && char <= '9') {\n    return true;\n  }\n\n  return char === '_' || char === '-' || char === varPrefix || char === wildcard;\n}\n\n/** Calculates the end of an array element\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the array element\n */\nfunction endOfArrayElement(value, start) {\n  for (let i = start + 1; i < value.length; i += 1) {\n    if (value[i] === blockSeperator || value[i] === arraySeperator) {\n      return i;\n    }\n  }\n\n  return value.length;\n}\n\n/** Calculates the end of a scope block\n * @param {string} category - Value to use when returning an error for our category\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the scope block\n */\nfunction endOfBlock(category, value, start) {\n  for (let i = start; i < value.length; i += 1) {\n    if (value[i] === blockSeperator) {\n      return i;\n    } if (value[i] === arraySeperator) {\n      continue;\n    } else if (!isValidCharacter(value[i])) {\n      throw new Error(`scopie-100 in ${category}: invalid character '${value[i]}'`);\n    }\n  }\n\n  return value.length;\n}\n\n/** Compares two strings with respect to variables and wildcards.\n * @param {string} aValue\n * @param {int} aLeft\n * @param {int} aSlider\n * @param {string} bValue\n * @param {int} bLeft\n * @param {int} bSlider\n * @param {Map<string,string>} vars\n * @returns {boolean} Whether or not our actor matches the action block\n */\nfunction compareBlock(aValue, aLeft, aSlider, bValue, bLeft, bSlider, vars) {\n  let actorLeft = aLeft;\n\n  if (aValue[actorLeft] === varPrefix) {\n    const key = aValue.substring(actorLeft + 1, aSlider);\n    if (!vars.has(key)) {\n      throw new Error(`scopie-104 in actor: variable '${key}' not found`);\n    }\n\n    const varValue = vars.get(key);\n    return varValue === bValue.substring(bLeft, bSlider);\n  }\n\n  if (aSlider - actorLeft === 1 && aValue[actorLeft] === wildcard) {\n    return true;\n  }\n\n  if (aValue.substring(actorLeft, aSlider).indexOf(arraySeperator) >= 0) {\n    for (;actorLeft < aSlider;) {\n      const arrayRight = endOfArrayElement(aValue, actorLeft);\n\n      if (aValue[actorLeft] === varPrefix) {\n        throw new Error(`scopie-101 in actor: variable '${aValue.substring(actorLeft + 1, arrayRight)}' found in array block`);\n      }\n\n      if (aValue[actorLeft] === wildcard) {\n        if (arrayRight - actorLeft > 1 && aValue[actorLeft + 1] === wildcard) {\n          throw new Error('scopie-103 in actor: super wildcard found in array block');\n        }\n\n        throw new Error('scopie-102 in actor: wildcard found in array block');\n      }\n\n      if (aValue.substring(actorLeft, arrayRight) === bValue.substring(bLeft, bSlider)) {\n        return true;\n      }\n\n      actorLeft = arrayRight + 1;\n    }\n\n    return false;\n  }\n\n  return aValue.substring(aLeft, aSlider) === bValue.substring(bLeft, bSlider);\n}\n\n/** Determines if an actor matches an action\n * @param {string} actor - Actor scope\n * @param {string} action - Action rule\n * @param {Map<string,string>} vars - Variables for translations\n * @returns {boolean} Whether or not the actor matches the rule\n */\nfunction compareActorToAction(actor, action, vars) {\n  // Skip the allow and deny prefix for actors\n  let actorLeft = endOfBlock('actor', actor, 0) + 1;\n  let actionLeft = 0;\n  let actionSlider = 0;\n  let actorSlider = 0;\n\n  for (; actorLeft < actor.length || actionLeft < action.length;) {\n    // In case one is longer then the other\n    if ((actorLeft < actor.length) !== (actionLeft < action.length)) {\n      return false;\n    }\n\n    actionSlider = endOfBlock('action', action, actionLeft);\n    actorSlider = endOfBlock('actor', actor, actorLeft);\n\n    // Super wildcards are checked here as it skips the who rest of the checks.\n    if (\n      actorSlider - actorLeft === 2\n      && actor[actorLeft] === wildcard\n      && actor[actorLeft + 1] === wildcard\n    ) {\n      if (actor.length > actorSlider) {\n        throw new Error('scopie-105 in actor: super wildcard not in the last block');\n      }\n\n      return true;\n    }\n    if (!compareBlock(\n      actor,\n      actorLeft,\n      actorSlider,\n      action,\n      actionLeft,\n      actionSlider,\n      vars,\n    )) {\n      return false;\n    }\n\n    actionLeft = actionSlider + 1;\n    actorLeft = actorSlider + 1;\n  }\n\n  return true;\n}\n\n/**\n * Validate if our actor is allowed to perform the action based on the required scope.\n * @param {string[]} actionScopes - Required actor scopes\n * @param {string[]} actorRules - What scopes our actor has\n * @param {object} vars - User variables that are replacable in scopes\n */\nexport function isAllowed(actionScopes, actorRules, vars) {\n  if (actorRules.length === 0) {\n    return false;\n  }\n\n  if (actionScopes.length === 0) {\n    throw new Error('scopie-106: action scopes was empty');\n  }\n\n  let varMap;\n  if (vars) {\n    varMap = new Map(Object.entries(vars));\n  }\n\n  let hasBeenAllowed = false;\n\n  for (let ruleIndex = 0; ruleIndex < actorRules.length; ruleIndex += 1) {\n    const actorRule = actorRules[ruleIndex];\n    if (actorRule.length === 0) {\n      throw new Error('scopie-106: actor rule was empty');\n    }\n\n    const isAllowBlock = actorRule[0] === 'a';\n    if (isAllowBlock && hasBeenAllowed) {\n      continue;\n    }\n\n    for (let actionIndex = 0; actionIndex < actionScopes.length; actionIndex += 1) {\n      const actionScope = actionScopes[actionIndex];\n      if (actionScope.length === 0) {\n        throw new Error('scopie-106: action scope was empty');\n      }\n\n      const match = compareActorToAction(actorRule, actionScope, varMap);\n      if (match && isAllowBlock) {\n        hasBeenAllowed = true;\n      } else if (match && !isAllowBlock) {\n        return false;\n      }\n    }\n  }\n\n  return hasBeenAllowed;\n}\n\n/**\n * Determines whether or not the scope is valid according to scopie rules.\n * @param {string} scope - Scope to check\n * @returns {Error|undefined} If the scope is invalid, the validation error is returned,\n * otherwise undefined is returned.\n */\nexport function validateScope(scope) {\n  if (scope === '') {\n    return new Error('scopie-106: scope was empty');\n  }\n\n  let inArray = false;\n\n  for (let i = 0; i < scope.length; i += 1) {\n    if (scope[i] === blockSeperator) {\n      inArray = false;\n      continue;\n    }\n\n    if (scope[i] === arraySeperator) {\n      inArray = true;\n      continue;\n    }\n\n    if (inArray) {\n      if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard) {\n        return new Error('scopie-103: super wildcard found in array block');\n      }\n\n      if (scope[i] === wildcard) {\n        return new Error('scopie-102: wildcard found in array block');\n      }\n\n      if (scope[i] === varPrefix) {\n        const end = endOfArrayElement(scope, i);\n        return new Error(`scopie-101: variable '${scope.substring(i + 1, end)}' found in array block`);\n      }\n    }\n\n    if (!isValidCharacter(scope[i])) {\n      return new Error(`scopie-100: invalid character '${scope[i]}'`);\n    }\n\n    if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard\n      && i < scope.length - 2) {\n      return new Error('scopie-105: super wildcard not in the last block');\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": []
}
