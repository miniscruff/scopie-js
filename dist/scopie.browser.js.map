{
  "version": 3,
  "sources": ["../src/scopie.js"],
  "sourcesContent": ["export const arraySeperator = '|';\nexport const blockSeperator = '/';\nexport const wildcard = '*';\nexport const varPrefix = '@';\n\nexport const allowPermission = \"allow\";\nexport const denyPermission = \"deny\";\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a scope.\n */\nfunction isValidCharacter(char) {\n  if (char >= 'a' && char <= 'z') {\n    return true;\n  }\n\n  if (char >= 'A' && char <= 'Z') {\n    return true;\n  }\n\n  if (char >= '0' && char <= '9') {\n    return true;\n  }\n\n  return char === '_' || char === '-' || char === varPrefix || char === wildcard;\n}\n\n/** Calculates the end of an array element\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the array element\n */\nfunction endOfArrayElement(value, start) {\n  for (let i = start + 1; i < value.length; i += 1) {\n    if (value[i] === blockSeperator || value[i] === arraySeperator) {\n      return i;\n    }\n  }\n\n  return value.length;\n}\n\n/** Calculates the end of a scope block\n * @param {string} category - Value to use when returning an error for our category\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the scope block\n */\nfunction endOfBlock(category, value, start) {\n  for (let i = start; i < value.length; i += 1) {\n    if (value[i] === blockSeperator) {\n      return i;\n    } if (value[i] === arraySeperator) {\n      continue;\n    } else if (!isValidCharacter(value[i])) {\n      throw new Error(`scopie-100 in ${category}: invalid character '${value[i]}'`);\n    }\n  }\n\n  return value.length;\n}\n\n/** Compares two strings with respect to variables and wildcards.\n * @param {string} rule\n * @param {int} ruleLeft\n * @param {int} ruleSlider\n * @param {string} scope\n * @param {int} scopeLeft\n * @param {int} scopeSlider\n * @param {Map<string,string>} vars\n * @returns {boolean} Whether or not our rule block matches the scope block\n */\nfunction compareBlock(rule, ruleLeft, ruleSlider, scope, scopeLeft, scopeSlider, vars) {\n  if (rule[ruleLeft] === varPrefix) {\n    const key = rule.substring(ruleLeft + 1, ruleSlider);\n    if (!vars.has(key)) {\n      throw new Error(`scopie-104: variable '${key}' not found`);\n    }\n\n    const varValue = vars.get(key);\n    return varValue === scope.substring(scopeLeft, scopeSlider);\n  }\n\n  if (ruleSlider - ruleLeft === 1 && rule[ruleLeft] === wildcard) {\n    return true;\n  }\n\n  if (rule.substring(ruleLeft, ruleSlider).indexOf(arraySeperator) >= 0) {\n    for (; ruleLeft < ruleSlider;) {\n      const arrayRight = endOfArrayElement(rule, ruleLeft);\n\n      if (rule[ruleLeft] === varPrefix) {\n        throw new Error(`scopie-101: variable '${rule.substring(ruleLeft + 1, arrayRight)}' found in array block`);\n      }\n\n      if (rule[ruleLeft] === wildcard) {\n        if (arrayRight - ruleLeft > 1 && rule[ruleLeft + 1] === wildcard) {\n          throw new Error('scopie-103: super wildcard found in array block');\n        }\n\n        throw new Error('scopie-102: wildcard found in array block');\n      }\n\n      if (rule.substring(ruleLeft, arrayRight) === scope.substring(scopeLeft, scopeSlider)) {\n        return true;\n      }\n\n      ruleLeft = arrayRight + 1;\n    }\n\n    return false;\n  }\n\n  return rule.substring(ruleLeft, ruleSlider) === scope.substring(scopeLeft, scopeSlider);\n}\n\n/** Determines if an rule matches a scope\n * @param {string} scope\n * @param {string} rule\n * @param {Map<string,string>} vars - Variables for translations\n * @returns {boolean} Whether or not the scope matches the rule\n */\nfunction compareScopeToRule(scope, rule, vars) {\n  // Skip the allow and deny prefix for rules\n  let ruleLeft = endOfBlock('rule', rule, 0) + 1;\n  let scopeLeft = 0;\n  let ruleSlider = 0;\n  let scopeSlider = 0;\n\n  for (; ruleLeft < rule.length || scopeLeft < scope.length;) {\n    // In case one is longer then the other\n    if ((ruleLeft < rule.length) !== (scopeLeft < scope.length)) {\n      return false;\n    }\n\n    scopeSlider = endOfBlock('scope', scope, scopeLeft);\n    ruleSlider = endOfBlock('rule', rule, ruleLeft);\n\n    // Super wildcards are checked here as it skips the who rest of the checks.\n    if (\n      ruleSlider - ruleLeft === 2\n      && rule[ruleLeft] === wildcard\n      && rule[ruleLeft + 1] === wildcard\n    ) {\n      if (rule.length > ruleSlider) {\n        throw new Error('scopie-105: super wildcard not in the last block');\n      }\n\n      return true;\n    }\n    if (!compareBlock(\n      rule,\n      ruleLeft,\n      ruleSlider,\n      scope,\n      scopeLeft,\n      scopeSlider,\n      vars,\n    )) {\n      return false;\n    }\n\n    scopeLeft = scopeSlider + 1;\n    ruleLeft = ruleSlider + 1;\n  }\n\n  return true;\n}\n\n/**\n * Validate if our user is allowed to perform the action based on their rules and the required scopes.\n * @param {string[]} scopes - Required scopes\n * @param {string[]} rules - What rules our user has\n * @param {object} vars - User variables that are replacable in scopes\n */\nexport function isAllowed(scopes, rules, vars) {\n  if (rules.length === 0) {\n    return false;\n  }\n\n  if (scopes.length === 0) {\n    throw new Error('scopie-106 in scope: scopes was empty');\n  }\n\n  let varMap;\n  if (vars) {\n    varMap = new Map(Object.entries(vars));\n  }\n\n  let hasBeenAllowed = false;\n\n  for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex += 1) {\n    const rule = rules[ruleIndex];\n    if (rule.length === 0) {\n      throw new Error('scopie-106 in rule: rule was empty');\n    }\n\n    const isAllowBlock = rule[0] === 'a';\n    if (isAllowBlock && hasBeenAllowed) {\n      continue;\n    }\n\n    for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex += 1) {\n      const scope = scopes[scopeIndex];\n      if (scope.length === 0) {\n        throw new Error('scopie-106 in scope: scope was empty');\n      }\n\n      const match = compareScopeToRule(scope, rule, varMap);\n      if (match && isAllowBlock) {\n        hasBeenAllowed = true;\n      } else if (match && !isAllowBlock) {\n        return false;\n      }\n    }\n  }\n\n  return hasBeenAllowed;\n}\n\n/**\n * Determines whether or not the scopes or rules are valid according to scopie rules.\n * @param {string[]} scopeOrRules - Scope or rules to check\n * @returns {Error|undefined} If the scope is invalid, the validation error is returned,\n * otherwise undefined is returned.\n */\nexport function validateScopes(scopeOrRules) {\n  if (scopeOrRules.length === 0) {\n    return new Error('scopie-106: scopes are empty');\n  }\n\n  const isRules = scopeOrRules[0].startsWith(allowPermission) ||\n    scopeOrRules[0].startsWith(denyPermission)\n\n  for (let scope of scopeOrRules) {\n    if (scope.length === 0) {\n      return new Error('scopie-106: scope or rule was empty');\n    }\n\n    const isScopeRules = scope.startsWith(allowPermission) ||\n      scope.startsWith(denyPermission)\n    if (isRules != isScopeRules) {\n      return new Error('scopie-107: inconsistent array of scopes and rules');\n    }\n\n    let inArray = false;\n\n    for (let i = 0; i < scope.length; i += 1) {\n      if (scope[i] === blockSeperator) {\n        inArray = false;\n        continue;\n      }\n\n      if (scope[i] === arraySeperator) {\n        inArray = true;\n        continue;\n      }\n\n      if (inArray) {\n        if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard) {\n          return new Error('scopie-103: super wildcard found in array block');\n        }\n\n        if (scope[i] === wildcard) {\n          return new Error('scopie-102: wildcard found in array block');\n        }\n\n        if (scope[i] === varPrefix) {\n          const end = endOfArrayElement(scope, i);\n          return new Error(`scopie-101: variable '${scope.substring(i + 1, end)}' found in array block`);\n        }\n      }\n\n      if (!isValidCharacter(scope[i])) {\n        return new Error(`scopie-100: invalid character '${scope[i]}'`);\n      }\n\n      if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard\n        && i < scope.length - 2) {\n        return new Error('scopie-105: super wildcard not in the last block');\n      }\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": []
}
