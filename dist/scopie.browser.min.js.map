{
  "version": 3,
  "sources": ["../src/scopie.js"],
  "sourcesContent": ["export const arraySeperator = '|';\nexport const blockSeperator = '/';\nexport const wildcard = '*';\nexport const varPrefix = '@';\n\n/** Checks character validity\n * @param {character} char - Single character to check\n * @returns {boolean} whether or not the character is valid within a scope.\n */\nfunction isValidCharacter(char) {\n  if (char >= 'a' && char <= 'z') {\n    return true;\n  }\n\n  if (char >= 'A' && char <= 'Z') {\n    return true;\n  }\n\n  if (char >= '0' && char <= '9') {\n    return true;\n  }\n\n  return char === '_' || char === '-' || char === varPrefix || char === wildcard;\n}\n\n/** Calculates the end of an array element\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the array element\n */\nfunction endOfArrayElement(value, start) {\n  for (let i = start + 1; i < value.length; i += 1) {\n    if (value[i] === blockSeperator || value[i] === arraySeperator) {\n      return i;\n    }\n  }\n\n  return value.length;\n}\n\n/** Calculates the end of a scope block\n * @param {string} category - Value to use when returning an error for our category\n * @param {string} value - Value of our scope we are traversing\n * @param {number} start - Index to start searching from\n * @returns {number} index at the end of the scope block\n */\nfunction endOfBlock(category, value, start) {\n  for (let i = start; i < value.length; i += 1) {\n    if (value[i] === blockSeperator) {\n      return i;\n    } if (value[i] === arraySeperator) {\n      continue;\n    } else if (!isValidCharacter(value[i])) {\n      throw new Error(`scopie-100 in ${category}: invalid character '${value[i]}'`);\n    }\n  }\n\n  return value.length;\n}\n\n/** Compares two strings with respect to variables and wildcards.\n * @param {string} aValue\n * @param {int} aLeft\n * @param {int} aSlider\n * @param {string} bValue\n * @param {int} bLeft\n * @param {int} bSlider\n * @param {Map<string,string>} vars\n * @returns {boolean} Whether or not our actor matches the action block\n */\nfunction compareBlock(aValue, aLeft, aSlider, bValue, bLeft, bSlider, vars) {\n  let actorLeft = aLeft;\n\n  if (aValue[actorLeft] === varPrefix) {\n    const key = aValue.substring(actorLeft + 1, aSlider);\n    if (!vars.has(key)) {\n      throw new Error(`scopie-104 in actor: variable '${key}' not found`);\n    }\n\n    const varValue = vars.get(key);\n    return varValue === bValue.substring(bLeft, bSlider);\n  }\n\n  if (aSlider - actorLeft === 1 && aValue[actorLeft] === wildcard) {\n    return true;\n  }\n\n  if (aValue.substring(actorLeft, aSlider).indexOf(arraySeperator) >= 0) {\n    for (;actorLeft < aSlider;) {\n      const arrayRight = endOfArrayElement(aValue, actorLeft);\n\n      if (aValue[actorLeft] === varPrefix) {\n        throw new Error(`scopie-101 in actor: variable '${aValue.substring(actorLeft + 1, arrayRight)}' found in array block`);\n      }\n\n      if (aValue[actorLeft] === wildcard) {\n        if (arrayRight - actorLeft > 1 && aValue[actorLeft + 1] === wildcard) {\n          throw new Error('scopie-103 in actor: super wildcard found in array block');\n        }\n\n        throw new Error('scopie-102 in actor: wildcard found in array block');\n      }\n\n      if (aValue.substring(actorLeft, arrayRight) === bValue.substring(bLeft, bSlider)) {\n        return true;\n      }\n\n      actorLeft = arrayRight + 1;\n    }\n\n    return false;\n  }\n\n  return aValue.substring(aLeft, aSlider) === bValue.substring(bLeft, bSlider);\n}\n\n/** Determines if an actor matches an action\n * @param {string} actor - Actor scope\n * @param {string} action - Action rule\n * @param {Map<string,string>} vars - Variables for translations\n * @returns {boolean} Whether or not the actor matches the rule\n */\nfunction compareActorToAction(actor, action, vars) {\n  // Skip the allow and deny prefix for actors\n  let actorLeft = endOfBlock('actor', actor, 0) + 1;\n  let actionLeft = 0;\n  let actionSlider = 0;\n  let actorSlider = 0;\n\n  for (; actorLeft < actor.length || actionLeft < action.length;) {\n    // In case one is longer then the other\n    if ((actorLeft < actor.length) !== (actionLeft < action.length)) {\n      return false;\n    }\n\n    actionSlider = endOfBlock('action', action, actionLeft);\n    actorSlider = endOfBlock('actor', actor, actorLeft);\n\n    // Super wildcards are checked here as it skips the who rest of the checks.\n    if (\n      actorSlider - actorLeft === 2\n      && actor[actorLeft] === wildcard\n      && actor[actorLeft + 1] === wildcard\n    ) {\n      if (actor.length > actorSlider) {\n        throw new Error('scopie-105 in actor: super wildcard not in the last block');\n      }\n\n      return true;\n    }\n    if (!compareBlock(\n      actor,\n      actorLeft,\n      actorSlider,\n      action,\n      actionLeft,\n      actionSlider,\n      vars,\n    )) {\n      return false;\n    }\n\n    actionLeft = actionSlider + 1;\n    actorLeft = actorSlider + 1;\n  }\n\n  return true;\n}\n\n/**\n * Validate if our actor is allowed to perform the action based on the required scope.\n * @param {string[]} actionScopes - Required actor scopes\n * @param {string[]} actorRules - What scopes our actor has\n * @param {object} vars - User variables that are replacable in scopes\n */\nexport function isAllowed(actionScopes, actorRules, vars) {\n  if (actorRules.length === 0) {\n    return false;\n  }\n\n  if (actionScopes.length === 0) {\n    throw new Error('scopie-106: action scopes was empty');\n  }\n\n  let varMap;\n  if (vars) {\n    varMap = new Map(Object.entries(vars));\n  }\n\n  let hasBeenAllowed = false;\n\n  for (let ruleIndex = 0; ruleIndex < actorRules.length; ruleIndex += 1) {\n    const actorRule = actorRules[ruleIndex];\n    if (actorRule.length === 0) {\n      throw new Error('scopie-106: actor rule was empty');\n    }\n\n    const isAllowBlock = actorRule[0] === 'a';\n    if (isAllowBlock && hasBeenAllowed) {\n      continue;\n    }\n\n    for (let actionIndex = 0; actionIndex < actionScopes.length; actionIndex += 1) {\n      const actionScope = actionScopes[actionIndex];\n      if (actionScope.length === 0) {\n        throw new Error('scopie-106: action scope was empty');\n      }\n\n      const match = compareActorToAction(actorRule, actionScope, varMap);\n      if (match && isAllowBlock) {\n        hasBeenAllowed = true;\n      } else if (match && !isAllowBlock) {\n        return false;\n      }\n    }\n  }\n\n  return hasBeenAllowed;\n}\n\n/**\n * Determines whether or not the scope is valid according to scopie rules.\n * @param {string} scope - Scope to check\n * @returns {Error|undefined} If the scope is invalid, the validation error is returned,\n * otherwise undefined is returned.\n */\nexport function validateScope(scope) {\n  if (scope === '') {\n    return new Error('scopie-106: scope was empty');\n  }\n\n  let inArray = false;\n\n  for (let i = 0; i < scope.length; i += 1) {\n    if (scope[i] === blockSeperator) {\n      inArray = false;\n      continue;\n    }\n\n    if (scope[i] === arraySeperator) {\n      inArray = true;\n      continue;\n    }\n\n    if (inArray) {\n      if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard) {\n        return new Error('scopie-103: super wildcard found in array block');\n      }\n\n      if (scope[i] === wildcard) {\n        return new Error('scopie-102: wildcard found in array block');\n      }\n\n      if (scope[i] === varPrefix) {\n        const end = endOfArrayElement(scope, i);\n        return new Error(`scopie-101: variable '${scope.substring(i + 1, end)}' found in array block`);\n      }\n    }\n\n    if (!isValidCharacter(scope[i])) {\n      return new Error(`scopie-100: invalid character '${scope[i]}'`);\n    }\n\n    if (scope[i] === wildcard && i < scope.length - 1 && scope[i + 1] === wildcard\n      && i < scope.length - 2) {\n      return new Error('scopie-105: super wildcard not in the last block');\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": ["isValidCharacter", "char", "endOfArrayElement", "value", "start", "i", "endOfBlock", "category", "compareBlock", "aValue", "aLeft", "aSlider", "bValue", "bLeft", "bSlider", "vars", "actorLeft", "key", "arrayRight", "compareActorToAction", "actor", "action", "actionLeft", "actionSlider", "actorSlider", "actionScopes", "actorRules", "varMap", "hasBeenAllowed", "ruleIndex", "actorRule", "isAllowBlock", "actionIndex", "actionScope", "match", "scope", "inArray", "end"]
}
